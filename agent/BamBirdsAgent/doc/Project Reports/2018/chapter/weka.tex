% this has not been implemented. It might be in the future though, after further evaluation.


\section{Weka Machine Learning \textit{not implemented yet}}
Disclaimer: this option of further improvement of the agent has not been implemented yet. It might be helpful in the future, though. Further investigation and evaluation is required. This chapter is just a description of current findings.

\subsection{Introduction}
Weka is a collection of machine learning algorithms for data mining tasks. It includes methods for data mining problems such as regression, classification, clustering, association rule mining, and attribute selection \footnote{Eibe Frank, Mark A. Hall, and Ian H. Witten (2016). The WEKA Workbench. Online Appendix for "Data Mining: Practical Machine Learning Tools and Techniques", Morgan Kaufmann, Fourth Edition, 2016.}. Weka is used by applying a learning algorithm to a given dataset and analyzing its output. Another way of using Weka, which is relevant for our use in BamBird agent, is to generate predictions on new instances, and a third way is to apply different learning algorithms and compare their outputs and performances.

\subsection{Implementation}
For the use in BamBird, Weka is used to classify a new instance. The class to be learned is whether a shot is good or bad, this is called a relation in Weka. This relation is dependent on attributes, and the attributes for the BamBird agent are, strategy name, confidence class, damage points and pigs killed. Weka uses an ARFF \footnote{https://www.cs.waikato.ac.nz/ml/weka/arff.html}. file. The ARFF file contains two sections, the header section and the data section. We give a brief description. Below we show the header of the ARFF file. The header contains the relation, a list of attributes and their data types.

The header section of the ARFF file looks like this:
\begin{lstlisting}
@relation good-shot
@attribute strategy-name 	{targetPig ,domino, blackBird,
	collapseStructure, tnt, heavyObject, whiteBird}
@attribute confidence-class	{A, B, C}
@attribute damage-points	REAL
@attribute pigs-killed		REAL
@attribute class		{good, bad}
\end{lstlisting}
\ \\
The header section of the ARFF file is followed by the ARFF Data Section. It contains the data declaration line and the dataset. Below we show a snapshot of our training dataset. Default values from section 4.1 are used to mark a shot as good or bad. Confidence class is identified as follows: class A from 0.5 to 0.6, class B from 0.6 to 0.9 and class C from 0.9 to 1.0. The Data Section looks like this:

\begin{lstlisting}
@data

domino,C,0,0,bad
domino,C,0,0,bad
targetPig,C,8760,2,good
domino,C,16100,3,good
targetPig,C,5320,2,good
targetPig,C,12530,3,good
targetPig,A,1160,0,bad
targetPig,A,6440,2,good
heavyObject,C,32580,6,good
\end{lstlisting}
\ \\
In order to classify a new instance, a new ARFF file is created at runtime, called \texttt{unknown.arff}. The header of \texttt{unknown.arff} is the same as the header described above, but the data section is different. Instead of having an entire dataset, only one data is provided, described below.
\ \\
\ \\
\texttt{targetPig, A, ?, ?, ?}
\ \\
\ \\
The \texttt{?} is the dataset signifies unknown data. To classify this instance, we know that the strategy is \texttt{targetPig} and we know that the \texttt{confidence-class} is \texttt{A}, but \texttt{damage-points}, \texttt{pigs-killed} and shot \texttt{class} are unknown. We use the NaiveBayes algorithm as implemented by Weka to classify this new instance.
\ \\
\ \\
Following we present the updated \texttt{Meta} algorithm for Weka and the \texttt{ClassifyShot} algorithm.

\begin{algorithm}[H]
\SetAlgoLined
load the ShotLearner database\;
\While{true}{
	\If{GameState != Playing}{
		choose new Level using the new equation\;
	}
	take a screenshot from the scene and analyse\;
	generate plans\;
	select the first Target from the plans and send it to WekaTester\;
	WekaTester classifyShot marks the Target good or bad\;
	\uIf{goodTarget}{
		execute the seleted shot\;
	} \uElse{
	remove the target from plan\;
	go to 8.\;
	}
	add shot to the shot-list of the current level\;
	\If{GameState == WON or GameState == LOST}{
	add level to database\;	
	}
	add the shot to ShotLearnerDatabase\;
	create a ShotResult object with the results of the shot\;
	save the ShotResult to a log file\;
}
	 \caption{Meta-Updated} \label{algorithm:metaUpdated}
\end{algorithm}
\ \\
Line 7 â€“ 14 mark the difference in the updated \texttt{Meta} algorithm. A \texttt{Target} is selected from the generated list of plans and is sent to \texttt{WekaTester}, where this target is transformed into an instance and written to \texttt{unknown.arff} file.
\ \\
\ \\
\begin{algorithm}[H]
\SetAlgoLined
create unknown.arff file\;
write the header\;
transform target into ARFF data instance\;
invoke NaiveBayes classifyInstance and save into prediction string\;
return prediction string\;

\caption{Weka: ClassifyShot}\label{algorithm:classifyShot}
\end{algorithm}
\ \\

There are two points of interest in Algorithm \ref{algorithm:classifyShot}. The first is the transformation of \texttt{Target} object into ARFF data instance. This is trivial and is achieved by string manipulation and string writing onto the \texttt{unknown.arff} file. The second interest point is the invoking of \texttt{classifyInstance} of \texttt{NaivesBayes} algorithm. This is also trivial because the logic is abstracted behind a simple method call, shown below.
\ \\
\ \\
\texttt{double predNB = nb.classifyInstance(newInst);} \footnote{http://weka.sourceforge.net/doc.stable/}
\ \\
\ \\
where \texttt{predNB } is the predicted class, \texttt{nb} is the instance of \texttt{NaiveBayes} class algorithm and newInst
is the new data instance that we wish to classify and predict the class of.
\ \\
\ \\
Implementing learning algorithms from Weka promise to be of use for the BamBird agent, but have not been implemented yet.