\section{Open Tasks for 2019}\label{ch:todo}

% Whatever we coudn't finish and hope the next team will tackle.
% Be as specific as possible, this makes it easier for the next team to start ;)

This chapter summarizes our key findings and things that are left undone. Below just a listing of possible tasks for the next project group:

\begin{description}
	\item[Fix `no retry after 3 failed attempts']
	During the finals in the last competition our agent couldn't complete \num{5} out of \num{8} levels. Current level selection strategy (\class{meta.LevelSelection}) will try every level three times. If we couldn't complete the level by then, it will load an already played level and try to improve the score. However, this makes absolutely no sense in the competition environment. Moreover the complete level selection strategy should be revised as the current selection is rather linear.
	
	\item[Better handle crowded scenes]
	Another very critical task is the performance in crowded scenes. Our agent performed worst in situations where the scene contained a lot of objects. Other (simulation) agents achieved high scores in those levels whereas our agent couldn't even complete with a low score. Currently the target point reachability calculation (\class{features.Scene:setReachabilityForAllBlocks()}) will create up to \num{5} targets per object. Besides a potential performance loss, this behavior may influence Prolog's decision making; too many targets distraction. Future versions should stick to just a single target per object (if there are many objects in the scene). Furthermore, the Prolog strategy needs some major adjustments to identify targets with similar behavior. Or even better, let Prolog do the reachability calculation only for those targets that are important.
	
	\item[Prolog parabola estimation]
	As mentioned before the reachability calculation can be moved to Prolog entirely (partially already done). Whats left undone is to restructure the communication flow Java $\leftrightarrows$ Prolog. Currently, Java runs some image processing, calculates reachability for all objects, creates a \source{situation.pl} file describing the scene, and starts Prolog to evaluate the options. There are two options to improve the message flow. Either find a way to communicate both ways directly (instead of an indirect Prolog call); Or start the communication from the Prolog part. Java will only run the image processing and write a scene description. Prolog then calculates the reachability for important targets only and sends the target list to java to perform the shot.
	
	\item[Scene scale by considering all objects]
	Current scene scale estimation relies on a robust detection of the slingshot (width and height). The idea was to use all scene objects' dimensions instead. More objects means also more errors during detection. Since we know how big the objects should be a clustering algorithm can group similar sizes together. The overall uncertainty should decrease with more measures (at least thats what we hope for).
	
	\item[Parabola equation overlap]
	An issue described in section \ref{ch:shot:launchAngle} may produce wrong parabola estimations. Since all birds have two equations (one for low and one for very-high shots) the launch angle area between those two equations may be incorrect. We didn't have the time to look deeper into this. Currently, the launch angle refinement is done in either one of these equations. But after selecting one we will not check if the best solution is in fact in the other one.
	
	\item[Yellow Bird target correction]
	As described in section \ref{ch:shot:yellowbird} the yellow bird estimation needs to be adapted to allow parabola correction. Also, finding a use for the implemented, but not used, fixed-angle-estimation.
	
	\item[ClientActionRobotJava]
	We use \class{meta.ActionRobot} to handle the Client-Server communication. Our robot is a subclass of \class{ab.demo.other.ClientActionRobotJava} and doesn't support going from the main menu to the level selection (all other agents from the competition do). However \class{ab.demo.other.ActionRobot} has this functionality built-in. Adopting the changes from the latter one to our solution; Or rewriting our robot to be a subclass of the latter one is an open task.
	
	\item[Random Levelgenerator]
	In section \ref{Random LevelGenerator} we described the random levelgenerator with its different types of levels.
	Currently the different structures cannot be combined in one level this is a goal that should be achieved in the future. The birds the client can shoot with are four red birds but need to be adapted to the structure, the type of pigs and the material in the generated level. Additionally, it should be possible to position the random blocks around the different structures without destroying them. For this we wanted to use an array that contains the used x-values so the random blocks, pigs and terrains are not colliding with the structure. If the structure is off the ground it would be helpful to track their height aswell. This allows to put random things on the ground if the structure is above it and if multiple structures are put together in one level later on it can be seen if they collide (in the air and on the ground).
\end{description}

